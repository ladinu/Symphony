<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>xmlrpc.rb</title>
  <link rel="stylesheet" href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <table cellspacing=0 cellpadding=0>
  <thead>
    <tr>
      <th class=docs><h1>xmlrpc.rb</h1></th>
      <th class=code></th>
    </tr>
  </thead>
  <tbody>
    <tr id='section-1'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-1">&#182;</a>
        </div>
        <p>This XMLRPC module is a liteweight and easy to use <code>XMLRPC</code> module written in â‰ˆ200 lines of code. 
I decided to write this module for the following reasons.</p>

<p>I wanted to learn Ruby. I&#39;m currently working on a MacOS specific port (named <a href="https://github.com/ladinu/Symphony">Symphony</a>) of 
<a href="http://6xq.net/projects/pianobar/">pianobar</a> written in <a href="http://www.macruby.org">MacRuby</a>. Because <a href="http://www.pandora.com">Pandora</a> use XMLRPC, I needed a lightweight 
and easy to use XMLRPC library. What better way to learn Ruby than writing my own XMLRPC library?</p>

<p>I also needed an easy-to-use and lightweight XMLRPC library. Ruby&#39;s default XMLRPC client does not 
offer easy access to XMLRPC data. Because XMLRPC calls to pandora servers needs to be encrypted, 
trying to implement XMLRPC data encryption/decryption in default Ruby XMLRPC library is very 
difficult.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-2'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-2">&#182;</a>
        </div>
        
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-License/Credits'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-License/Credits">&#182;</a>
        </div>
        <h3>License/Credits</h3>

<p>This software is released under the <a href="http://www.opensource.org/licenses/MIT">MIT</a> License.
Please reffer to the <a href="http://www.google.com">license</a> located at github.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-XML_Remote_Procedure_Call'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-XML_Remote_Procedure_Call">&#182;</a>
        </div>
        <h3>XML Remote Procedure Call</h3>

<p>If you are not familiar with XMLRPC, please read the <a href="http://xmlrpc.scripting.c#%20om/spec.html">XMLRPC specifications</a>.</p>

<p>Here is a quick overview:</p>

<p><em>XMLRPC</em> stands for XML Remote Procedure Call. XMLRPC is usually used for invoking certain 
 actions on a remote server by a client. In a XMLRPC request, the string enclosed in 
 <code>&lt;methodName&gt;</code> tag is called the method name. Data enclosed in <code>&lt;param&gt;</code> tags are the parameters for 
 the method call.</p>

<p>XMLRPC allows for eight data structures/types for parameters:</p>

<ul>
<li>integers</li>
<li>strings</li>
<li>booleans, </li>
<li>doubles/floats</li>
<li>date/time (encoded in <a href="http://en.wikipedia.org/wiki/ISO_8601">iso8601</a>)</li>
<li>base64 (for binary data)</li>
<li>arrays</li>
<li>structs</li>
</ul>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-5'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-5">&#182;</a>
        </div>
        <p>The following is an example XMLRPC request where the method <em>listener.authenticateListener</em> is 
invoked on a remote server given the parameters <em>john.doe@mail.com</em> and <em>password123</em>.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-6'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-6">&#182;</a>
        </div>
        <p><code>&lt;?xml version=\&quot;1.0\&quot; ?&gt;
&lt;methodCall&gt;
&lt;methodName&gt;listener.authenticateListener&lt;/methodName&gt;
  &lt;params&gt;
     &lt;param&gt;&lt;value&gt;&lt;string&gt;john.doe@mail.com&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;
     &lt;param&gt;&lt;value&gt;&lt;string&gt;password123&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;</code></p>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-XMLRPC_Module_Documentation'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-XMLRPC_Module_Documentation">&#182;</a>
        </div>
        <h3>XMLRPC Module Documentation</h3>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-8'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-8">&#182;</a>
        </div>
        <p>The XMLRPC module has two classes, <code>Call</code> and <code>Parser</code>. They are responsible for creating XMLRPC 
requests and parsing XMLRPC responses. <code>Parser</code> will parse XMLRPC responses to native ruby data structures/types.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><span class="k">module</span> <span class="nn">XMLRPC</span></pre></div>
      </td>
    </tr>
    <tr id='section-9'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-9">&#182;</a>
        </div>
        <p>Call object has only one read-only accessor <code>@xml</code>. <code>@xml</code> holds the actual XMLRPC request string.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>  <span class="k">class</span> <span class="nc">Call</span>
    <span class="kp">attr_reader</span> <span class="ss">:xml</span></pre></div>
      </td>
    </tr>
    <tr id='section-10'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-10">&#182;</a>
        </div>
        <p><code>new_call(method, *params)</code> creates an XMLRPC request when called with a method name and zero or more
param(s). Because an XMLRPC request can have multiple parameters, the <code>*</code> is used in <code>new_call</code>.</p>

<p>For example,</p>

<pre><code>  Call.new_call(&#39;user.athenticate&#39;, &#39;username&#39;, &#39;passwd&#39;)
  Call.new_call(&#39;user.reply&#39;, 1, [1, 2, &#39;foo&#39;], &quot;string&quot;)
  Call.new_call(&#39;user.Auth&#39;) # A request without parameters
</code></pre>

<p>The first argument to <code>new_call</code> must be the XMLRPC method name and the rest can be the XMLRPC supported
data types.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">new_call</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">valid_method_name?</span> <span class="nb">method</span>
        <span class="vi">@method</span> <span class="o">=</span> <span class="nb">method</span>
        <span class="nb">self</span><span class="o">.</span><span class="n">make_xml</span> <span class="n">params</span>
      <span class="k">else</span>
        <span class="k">raise</span>  <span class="s2">&quot;[!] Method name &#39;</span><span class="si">#{</span><span class="nb">method</span><span class="si">}</span><span class="s2">&#39; is an invalid XMLRPC method name&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-11'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-11">&#182;</a>
        </div>
        <p><code>valid_method_name?(methodName)</code> checks for correct method names according to the XMLRPC specifications
(see <em>Payload Format</em> section at <a href="http://xmlrpc.scripting.com/spec.html">http://xmlrpc.scripting.com/spec.html</a>). 
<code>valid_method_name(methodName)</code> is called by <code>new_call</code> before creating the XMLRPC request.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">valid_method_name?</span><span class="p">(</span><span class="n">methodName</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">methodName</span><span class="o">.</span><span class="n">class</span> <span class="o">==</span> <span class="nb">String</span></pre></div>
      </td>
    </tr>
    <tr id='section-12'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-12">&#182;</a>
        </div>
        <p>A regular expression is used to match correct XMLRPC method names.</p>

<p>For example,</p>

<pre><code>Call.valid_method_name? &#39;sample.method&#39;     # =&gt; true
Call.valid_method_name? &#39;sAmPLe._meth0d:9/&#39; # =&gt; true

Call.valid_method_name? &#39;sample-method&#39;     # =&gt; false
Call.valid_method_name? &#39;s#ample.method&#39;    # =&gt; false
</code></pre>
      </td>
      <td class=code>
        <div class='highlight'><pre>        <span class="n">valid_method_name</span> <span class="o">=</span> <span class="sr">/^[[:alpha:][:digit:]\.:_\/]+$/</span>
       
       <span class="k">if</span> <span class="n">methodName</span><span class="o">.</span><span class="n">match</span> <span class="n">valid_method_name</span>
         <span class="kp">true</span>
       <span class="k">else</span>
         <span class="kp">false</span>
       <span class="k">end</span>

      <span class="k">else</span>
        <span class="k">raise</span> <span class="s2">&quot;Method &#39;</span><span class="si">#{</span><span class="n">methodName</span><span class="si">}</span><span class="s2">&#39; must be a string&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-13'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-13">&#182;</a>
        </div>
        <p><code>make_xml(params)</code> is called by <code>new_call</code>. <code>make_xml</code> method create the actual XMLRPC request.
<code>make_xml</code> calls <code>make_xml_value</code> for every value in <code>params</code>, and append the returning  value to <code>@xml</code>.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">make_xml</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

      <span class="vi">@xml</span> <span class="o">=</span> <span class="s2">&quot;&lt;?xml version=</span><span class="se">\&quot;</span><span class="s2">1.0</span><span class="se">\&quot;</span><span class="s2"> ?&gt;&lt;methodCall&gt;&lt;methodName&gt;</span><span class="si">#{</span><span class="vi">@method</span><span class="si">}</span><span class="s2">&lt;/methodName&gt;&lt;params&gt;&quot;</span>

      <span class="k">unless</span> <span class="n">params</span><span class="o">.</span><span class="n">empty?</span>
        <span class="n">params</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
          <span class="vi">@xml</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;param&gt;&lt;value&gt;&quot;</span>
          <span class="vi">@xml</span> <span class="o">&lt;&lt;</span> <span class="n">make_xml_value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
          <span class="vi">@xml</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;/value&gt;&lt;/param&gt;&quot;</span>
        <span class="k">end</span>
      <span class="k">end</span>
      <span class="vi">@xml</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;/params&gt;&lt;/methodCall&gt;&quot;</span>
    <span class="k">end</span>
      </pre></div>
      </td>
    </tr>
    <tr id='section-14'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-14">&#182;</a>
        </div>
        <p><code>make_xml_value(i)</code> checks the data type of <code>i</code> and retun the data type of <code>i</code> enclosed in XMLRPC data 
type/structure tag. When type if <code>i</code> is a <em>hash</em> or an <em>array</em>, <code>make_xml_value</code> use recursion to 
call it self to construct the <em>hash/array</em>.</p>

<p>For example,</p>

<pre><code>Call.make_xml_value &#39;some_str&#39; # =&gt;  &quot;&lt;string&gt;some_str&lt;/string&gt;&quot;
Call.make_xml_value 3.14159    # =&gt; &quot;&lt;double&gt;3.14159&lt;/double&gt;&quot;
Call.make_xml_value true       # =&gt; &quot;&lt;boolean&gt;1&lt;/boolean&gt;&quot;
</code></pre>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">make_xml_value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="k">case</span> <span class="n">i</span>
      <span class="k">when</span> <span class="nb">String</span>
        <span class="s2">&quot;&lt;string&gt;</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&lt;/string&gt;&quot;</span>
      <span class="k">when</span> <span class="no">Fixnum</span>
        <span class="s2">&quot;&lt;int&gt;</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&lt;/int&gt;&quot;</span>
      <span class="k">when</span> <span class="no">TrueClass</span>
        <span class="s2">&quot;&lt;boolean&gt;1&lt;/boolean&gt;&quot;</span>
      <span class="k">when</span> <span class="no">FalseClass</span>
        <span class="s2">&quot;&lt;boolean&gt;0&lt;/boolean&gt;&quot;</span>
      <span class="k">when</span> <span class="nb">Float</span>
        <span class="s2">&quot;&lt;double&gt;</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&lt;/double&gt;&quot;</span>
      <span class="k">when</span> <span class="nb">Array</span>
        <span class="n">array</span> <span class="o">=</span> <span class="s2">&quot;&lt;array&gt;&lt;data&gt;&quot;</span>
        <span class="n">i</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">array</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;value&gt;</span><span class="si">#{</span><span class="n">make_xml_value</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&lt;/value&gt;&quot;</span><span class="p">}</span>
        <span class="n">array</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;/data&gt;&lt;/array&gt;&quot;</span>

      <span class="k">when</span> <span class="no">Hash</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="s2">&quot;&lt;struct&gt;&quot;</span>
        <span class="n">i</span><span class="o">.</span><span class="n">each_pair</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
          <span class="n">struct</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;member&gt;&lt;name&gt;</span><span class="si">#{</span><span class="n">key</span><span class="si">}</span><span class="s2">&lt;/name&gt;&lt;value&gt;</span><span class="si">#{</span><span class="n">make_xml_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">&lt;/value&gt;&lt;/member&gt;&quot;</span>
        <span class="k">end</span>
        <span class="n">struct</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;/struct&gt;&quot;</span>

      <span class="k">else</span>
        <span class="k">raise</span> <span class="s2">&quot;Invalid XMLRPC value. &#39;</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&#39; doesn&#39;t match any scalar types...&quot;</span>
      <span class="k">end</span>

    <span class="k">end</span>
  <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-15'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-15">&#182;</a>
        </div>
        <p><code>Parser</code> object is responsible for parsing valid XMLRPC responses. When a XMLRPC response string is provided,<br>
<code>Parser</code> will parse the response into native Ruby data types/structures. <code>Parser</code> use the built-in Ruby XML 
parsing module <a href="http://www.germane-software.com/software/rexml/">REXML</a>. Most of the parsing is done using <a href="http://www.w3schools.com/xpath/xpath_examples.asp">XPath</a>.</p>

<p>Note that parsing large XMLRPC responses are very resource intensive and time consuming. This is largley due
to the way in which REXML is written. In future versions of this XMLRPC module, an alternative XML parsing
library will be supported.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>  <span class="k">class</span> <span class="nc">Parser</span>
    <span class="nb">require</span> <span class="s1">&#39;rexml/document&#39;</span>
    </pre></div>
      </td>
    </tr>
    <tr id='section-16'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-16">&#182;</a>
        </div>
        <p><code>Parser</code> has one public atribute named <code>@response</code>. <code>@response</code> hold the parsed XMLRPC response in native Ruby
data types/structures. The data type of <code>@response</code> is an array. Which will be populated later.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="kp">attr_reader</span> <span class="ss">:response</span></pre></div>
      </td>
    </tr>
    <tr id='section-17'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-17">&#182;</a>
        </div>
        <p>If <code>xml_response</code> is ptovided <code>parse</code> method is called.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">xml_response</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">parse</span> <span class="n">xml_response</span> <span class="k">if</span> <span class="n">xml_response</span>
    <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-18'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-18">&#182;</a>
        </div>
        <p><code>parse</code> method take a XML string for input. <code>parse</code> method populate the array <code>@response</code> with Ruby data types/
structures corresponding to the encoded data in the XMLRPC response.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">parse</span> <span class="p">(</span><span class="n">response</span><span class="p">)</span></pre></div>
      </td>
    </tr>
    <tr id='section-19'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-19">&#182;</a>
        </div>
        <p><code>parse</code> method first create a REXML document by passing in <code>response</code>.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="vi">@xml_response</span> <span class="o">=</span> <span class="no">REXML</span><span class="o">::</span><span class="no">Document</span><span class="o">.</span><span class="n">new</span> <span class="n">response</span>
      <span class="vi">@response</span>     <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span></pre></div>
      </td>
    </tr>
    <tr id='section-20'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-20">&#182;</a>
        </div>
        <p><code>parse</code> checks for fault XMLRPC response by searching for the path <code>methodResponse/fault</code> in the REXML
document (see <em>Response format</em> section at <a href="http://xmlrpc.scripting.com/spec.html">http://xmlrpc.scripting.com/spec.html</a>). If such path exist, 
then <code>parse</code> method will parse the fault code and fault string into a Ruby hash. Also, <code>:fault</code> symbol will
be added to <code>@response</code> as the first item.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">if</span> <span class="vi">@xml_response</span><span class="o">.</span><span class="n">elements</span><span class="o">[</span><span class="s1">&#39;methodResponse/fault&#39;</span><span class="o">]</span>
        <span class="vi">@response</span> <span class="o">&lt;&lt;</span> <span class="ss">:fault</span>
        
        <span class="vi">@xml_response</span><span class="o">.</span><span class="n">elements</span><span class="o">[</span><span class="s1">&#39;methodResponse/fault/value&#39;</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">fault_struct</span><span class="o">|</span> 
          <span class="n">parse_value</span> <span class="n">fault_struct</span>
        <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-21'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-21">&#182;</a>
        </div>
        <p>If a fault XMLRPC response was not found, then <code>parse</code> method looks for the path
<code>methodResponse/params/param/value</code>. If such path exist, then <code>parse</code> method continues on to parsing 
XMLRPC response values. <code>parse_value</code> method is called for parsing each scalar values such as string, int, 
bool etc.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">elsif</span> <span class="vi">@xml_response</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="s1">&#39;methodResponse/params/param/value&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>

          <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has_elements?</span>
            <span class="n">i</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">value</span><span class="o">|</span> <span class="nb">self</span><span class="o">.</span><span class="n">parse_value</span> <span class="n">value</span><span class="p">}</span>
          </pre></div>
      </td>
    </tr>
    <tr id='section-22'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-22">&#182;</a>
        </div>
        <p>If a XMLRPC response value is not enclosed in any tags, <code>nil</code> or the actual text of value will be added
to <code>@response</code>.</p>

<p>For example,</p>

<pre><code>  &lt;value&gt;FOO&lt;/value&gt; # text FOO will be added to @response
  &lt;value&gt;&lt;/value&gt;    # nil will be added to @response
</code></pre>
      </td>
      <td class=code>
        <div class='highlight'><pre>          <span class="k">else</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has_text?</span>
              <span class="vi">@response</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">.</span><span class="n">text</span>
            <span class="k">else</span>
              <span class="vi">@response</span> <span class="o">&lt;&lt;</span> <span class="kp">nil</span>
            <span class="k">end</span>
          <span class="k">end</span>
      <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-23'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-23">&#182;</a>
        </div>
        <p>If path <code>methodResponse/params/param/value</code> does not exist, then the input string <code>response</code> is an invalid
XMLRPC response. <code>parse</code> method raise an exception which display the first 256 characters of the <code>response</code> 
string.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">else</span>
        <span class="k">raise</span> <span class="s2">&quot;Invalid XMLRPC response: </span><span class="si">#{</span><span class="vi">@xml_response</span><span class="o">[</span><span class="mi">256</span><span class="o">]</span><span class="si">}</span><span class="s2">...&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-24'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-24">&#182;</a>
        </div>
        <p><code>parse_value</code> method accept two values: <code>value</code> and <code>response</code> (where <code>response</code> is optional). <code>value</code> is a
REXML data type passed from <code>parse</code> method.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">parse_value</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">response</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span></pre></div>
      </td>
    </tr>
    <tr id='section-25'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-25">&#182;</a>
        </div>
        <p>Fist, <code>parse_value</code> method checks if an alternative <code>response</code> variable is passed. If not, default 
<code>@response</code> will be used. Then <code>parse_value</code> store the name of <code>value</code> in <code>value_type</code>. 
For example, if <code>value</code> was <em>&lt;double&gt;2.71828183&lt;/double&gt;</em>, then <code>value_type</code> would be <em>double</em>.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="n">response</span> <span class="o">=</span> <span class="n">response</span> <span class="o">||</span> <span class="vi">@response</span>  <span class="c1"># When the value is a list, we do not want to effect the response list</span>
      <span class="n">value_type</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">name</span></pre></div>
      </td>
    </tr>
    <tr id='section-26'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-26">&#182;</a>
        </div>
        <p><code>parse_value</code> use a case statement to check for each possible XMLRPC data types. When a valid data type is
encountered, <code>value</code>&#39;s text is converted to a Ruby data type and appended to <code>response</code>. For example, 
if <code>value</code> was <em>&lt;double&gt;2.71828183&lt;/double&gt;</em>, then <code>value</code> text <em>&#39;2.71828183&#39;</em> would be converted to a 
float and appended to <code>response</code>.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">case</span> <span class="n">value_type</span>

      <span class="k">when</span> <span class="s1">&#39;string&#39;</span>
        <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="o">.</span><span class="n">text</span>
      <span class="k">when</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span>
        <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">to_i</span>
      <span class="k">when</span> <span class="s1">&#39;double&#39;</span>
        <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">to_f</span>
      <span class="k">when</span> <span class="s1">&#39;boolean&#39;</span>

        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span>
          <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="kp">false</span>
        <span class="k">elsif</span> <span class="n">value</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span>
          <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="kp">true</span>
        <span class="k">else</span>
          <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="ss">:invalid_boolean</span>
        <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-27'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-27">&#182;</a>
        </div>
        <p>When <code>value</code> is a XMLRPC <em>&lt;array&gt;</em> type, recursion is used to parse each item in the XMLRPC array. First
a new array is created. Then, for each item in <code>value</code>, <code>parse_value</code> is called like following:</p>

<p><code>parse_value(i, array)</code> where <code>i</code> is an item in the XMLRPC array and <code>array</code> is the newly crated array. 
Because the second argument <code>array</code> is passed, <code>parse_value</code> will append parsed items in the XMLRPC array 
into the <code>array</code> variable (which will be appended to <code>@response</code> eventually).</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">when</span> <span class="s1">&#39;array&#39;</span>
        <span class="n">array</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span>
        <span class="n">value</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="s1">&#39;data/value/*&#39;</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">parse_value</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">array</span><span class="p">)}</span>
        <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="n">array</span></pre></div>
      </td>
    </tr>
    <tr id='section-28'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-28">&#182;</a>
        </div>
        <p>When <code>value</code> is a XMLRPC <em>&lt;struct&gt;</em> type, recursion is again used to parse XMLRPC struct type to a native
Ruby hash. First two arrays are created, <code>hash_key</code> and <code>hash_values</code>. Then <code>hash_keys</code> is populated with 
each <em>&#39;member/name&#39;</em> of the XMLRPC struct. Then <code>hash_value</code> is populated with each <em>&#39;member/value&#39;</em> of the 
XMLRPC struct. </p>

<p>Because some XMLRPC response servers does not strictly adhere to XMLRPC specifications, extra work is done 
to make <code>Parser</code> compatible with such implementations. When the <em>&lt;value&gt;</em> tag is empty, <code>nil</code> is inserted
into <code>hash_values</code>. When <em>&lt;value&gt;</em> tag is not empty, the data enclosed in <em>&lt;value&gt;</em> tag is treated as a
plain string. Finally, the two arrays, <code>hash_values</code> and <code>hash_keys</code> is zipped into a Ruby hash an appended
to <code>response</code>.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">when</span> <span class="s1">&#39;struct&#39;</span>
        <span class="n">hash_keys</span>   <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span>
        <span class="n">hash_values</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span>

        <span class="n">value</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="s1">&#39;member/name&#39;</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">hash_keys</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">.</span><span class="n">text</span><span class="p">}</span>

        <span class="n">value</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="s1">&#39;member/value&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
          <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has_text?</span>
            <span class="n">hash_values</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">.</span><span class="n">text</span>
          <span class="k">elsif</span> <span class="n">i</span><span class="o">.</span><span class="n">has_elements?</span>
            <span class="n">i</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">parse_value</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">hash_values</span><span class="p">)}</span>
          <span class="k">else</span>
            <span class="n">hash_values</span> <span class="o">&lt;&lt;</span> <span class="kp">nil</span>
          <span class="k">end</span>
        <span class="k">end</span>

        <span class="n">h</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span>
        <span class="n">hash_keys</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">hash_values</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">h</span><span class="o">[</span><span class="n">i</span><span class="o">.</span><span class="n">first</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">last</span><span class="p">}</span>
        <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="n">h</span></pre></div>
      </td>
    </tr>
    <tr id='section-29'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-29">&#182;</a>
        </div>
        <p>If <code>value</code> does not match any XMLRPC data types this exception will be raised.</p>

      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">else</span>
        <span class="k">raise</span>  <span class="s2">&quot;[!] Could not parse scalar type &#39;</span><span class="si">#{</span><span class="n">value_type</span><span class="si">}</span><span class="s2">&#39; from xml&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span>

  <span class="k">end</span>

<span class="k">end</span></pre></div>
      </td>
    </tr>
  </table>
</div>
</body>
