<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>xmlrpc.rb</title>
  <link rel="stylesheet" href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <table cellspacing=0 cellpadding=0>
  <thead>
    <tr>
      <th class=docs><h1>xmlrpc.rb</h1></th>
      <th class=code></th>
    </tr>
  </thead>
  <tbody>
    <tr id='section-1'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-1">&#182;</a>
        </div>
        <p>This XMLRPC module is easy to use and liteweight and written in 200 lines of <a href="http://www.ruby-lang.org/">Ruby</a>
code. I decided to write this module for the following reasons:</p>

<p>First, I wanted to learn Ruby. I&#39;m working on a MacOS specific port (named <a href="https://github.com/ladinu/Symphony">Symphony</a>) of 
<a href="http://6xq.net/projects/pianobar/">pianobar</a> written in <a href="http://www.macruby.org">MacRuby</a>. Because <a href="http://www.pandora.com">Pandora</a> use XMLRPC, I decided to write
this module to get fimiliar with XMLRPC and Ruby.</p>

<p>Second, I needed a simple XMLRPC library. Ruby&#39;s default XMlRPC library is hard to use and does
not offer easy access to internal XMLRPC data. Also Ruby&#39;s default XMLRPC library is not a good choice
beacuse XMLRPC calls to Pandora servers need to be encrypted and responses to be decrypted.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-2'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-2">&#182;</a>
        </div>
        
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-License/Credits'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-License/Credits">&#182;</a>
        </div>
        <h3>License/Credits</h3>

<p>I release this software under the <a href="http://www.opensource.org/licenses/MIT">MIT</a> license.
Please reffer to the <a href="https://github.com/ladinu/Symphony/blob/master/symphony_core/license.txt">license</a> 
located at github. I also used <a href="http://rtomayko.github.com/rocco/">Rocco</a> to generate this doccumentation.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-XMLRPC_Overview'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-XMLRPC_Overview">&#182;</a>
        </div>
        <h3>XMLRPC Overview</h3>

<p>If you are not familiar with XMLRPC, please read the <a href="http://xmlrpc.scripting.com/spec.html">XMLRPC specifications</a>.</p>

<p><em>XMLRPC</em> stands for <em>XML Remote Procedure Call</em>. XMLRPC invoke methods on remote servers. The string
enclosed in <code>&lt;methodName&gt;</code> tag is called the method name. The strings enclosed in <code>&lt;param&gt;</code> tags are the data to the method
call.</p>

<p>The following data types/structures can be used in a XMLRPC request:</p>

<ul>
<li>integers</li>
<li>strings</li>
<li>booleans</li>
<li>doubles/floats</li>
<li>date/time (encoded in <a href="http://en.wikipedia.org/wiki/ISO_8601">iso8601</a>)</li>
<li>base64 (for binary data)</li>
<li>arrays</li>
<li>structs</li>
</ul>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-5'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-5">&#182;</a>
        </div>
        <p>This is an example of a XMLRPC request.</p>

<p><code>&lt;?xml version=\&quot;1.0\&quot; ?&gt;
  &lt;methodCall&gt;
  &lt;methodName&gt;listener.authenticateListener&lt;/methodName&gt;
    &lt;params&gt;
       &lt;param&gt;&lt;value&gt;&lt;string&gt;john.doe@mail.com&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;
       &lt;param&gt;&lt;value&gt;&lt;string&gt;password123&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;
    &lt;/params&gt;
  &lt;/methodCall&gt;</code></p>

<p>The string <em>listener.authenticateListener</em> is the method name. String <em>john.doe@mail.com</em> and string <em>password123</em> are the
parameters.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-XMLRPC_Module_Documentation'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-XMLRPC_Module_Documentation">&#182;</a>
        </div>
        <h3>XMLRPC Module Documentation</h3>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-7'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-7">&#182;</a>
        </div>
        <p>This XMLRPC module has two classes, <code>Call</code> and <code>Parser</code>. They create XMLRPC requests and parse XMLRPC responses. <code>Parser</code> will parse 
XMLRPC responses to Ruby data structures/types.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><span class="k">module</span> <span class="nn">XMLRPC</span></pre></div>
      </td>
    </tr>
    <tr id='section-Call'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-Call">&#182;</a>
        </div>
        <h4>Call</h4>

<p>Call object has one read-only accessor <code>@xml</code>. <code>@xml</code> holds XMLRPC request string.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>  <span class="k">class</span> <span class="nc">Call</span>
    <span class="kp">attr_reader</span> <span class="ss">:xml</span></pre></div>
      </td>
    </tr>
    <tr id='section-9'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-9">&#182;</a>
        </div>
        <p><code>new_call(method, *params)</code> creates a XMLRPC request string. Argument <code>*param</code> is optional. <code>*</code> is used in <code>new_call</code> because 
a XMLRPC request can have multiple parameters. If <code>*param</code> is provided, <code>*param</code> must contain XMLRPC supported data 
types/structures.</p>

<p>For example:</p>

<pre><code>  Call.new_call(&#39;user.athenticate&#39;, &#39;username&#39;, &#39;passwd&#39;)
  Call.new_call(&#39;user.reply&#39;, 1, [1, 2, &#39;foo&#39;], &quot;string&quot;)
  Call.new_call(&#39;list.sync&#39;) # A request without parameters
</code></pre>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">new_call</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">valid_method_name?</span> <span class="nb">method</span>
        <span class="vi">@method</span> <span class="o">=</span> <span class="nb">method</span>
        <span class="nb">self</span><span class="o">.</span><span class="n">make_xml</span> <span class="n">params</span>
      <span class="k">else</span>
        <span class="k">raise</span>  <span class="s2">&quot;[!] Method name &#39;</span><span class="si">#{</span><span class="nb">method</span><span class="si">}</span><span class="s2">&#39; is an invalid XMLRPC method name&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-10'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-10">&#182;</a>
        </div>
        <p><code>valid_method_name?(methodName)</code> check for correct XMLRPC method names (see <em>Payload Format</em> section at
<a href="http://xmlrpc.scripting.com/spec.html">http://xmlrpc.scripting.com/spec.html</a>).</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">valid_method_name?</span><span class="p">(</span><span class="n">methodName</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">methodName</span><span class="o">.</span><span class="n">class</span> <span class="o">==</span> <span class="nb">String</span></pre></div>
      </td>
    </tr>
    <tr id='section-11'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-11">&#182;</a>
        </div>
        <p>For examples:</p>

<pre><code>Call.valid_method_name? &#39;sample.method&#39;     # =&gt; true
Call.valid_method_name? &#39;sAmPLe._meth0d:9/&#39; # =&gt; true

Call.valid_method_name? &#39;sample-method&#39;     # =&gt; false
Call.valid_method_name? &#39;s#ample.method&#39;    # =&gt; false
</code></pre>
      </td>
      <td class=code>
        <div class='highlight'><pre>        <span class="n">valid_method_name</span> <span class="o">=</span> <span class="sr">/^[[:alpha:][:digit:]\.:_\/]+$/</span>
       
       <span class="k">if</span> <span class="n">methodName</span><span class="o">.</span><span class="n">match</span> <span class="n">valid_method_name</span>
         <span class="kp">true</span>
       <span class="k">else</span>
         <span class="kp">false</span>
       <span class="k">end</span>

      <span class="k">else</span>
        <span class="k">raise</span> <span class="s2">&quot;Method &#39;</span><span class="si">#{</span><span class="n">methodName</span><span class="si">}</span><span class="s2">&#39; must be a string&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-12'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-12">&#182;</a>
        </div>
        <p>Method <code>make_xml(params)</code> creates the XMLRPC request body. <code>valid_method_name?</code> call  <code>make_xml_value(i)</code> for every item in <code>params</code>.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">make_xml</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

      <span class="vi">@xml</span> <span class="o">=</span> <span class="s2">&quot;&lt;?xml version=</span><span class="se">\&quot;</span><span class="s2">1.0</span><span class="se">\&quot;</span><span class="s2"> ?&gt;&lt;methodCall&gt;&lt;methodName&gt;</span><span class="si">#{</span><span class="vi">@method</span><span class="si">}</span><span class="s2">&lt;/methodName&gt;&lt;params&gt;&quot;</span>

      <span class="k">unless</span> <span class="n">params</span><span class="o">.</span><span class="n">empty?</span>
        <span class="n">params</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
          <span class="vi">@xml</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;param&gt;&lt;value&gt;&quot;</span>
          <span class="vi">@xml</span> <span class="o">&lt;&lt;</span> <span class="n">make_xml_value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
          <span class="vi">@xml</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;/value&gt;&lt;/param&gt;&quot;</span>
        <span class="k">end</span>
      <span class="k">end</span>
      <span class="vi">@xml</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;/params&gt;&lt;/methodCall&gt;&quot;</span>
    <span class="k">end</span>
      </pre></div>
      </td>
    </tr>
    <tr id='section-13'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-13">&#182;</a>
        </div>
        <p>First, <code>make_xml_value(i)</code> check the data type of <code>i</code>. Then <code>make_xml</code> enclose <code>i</code> in appropriate data tags. If data type of
<code>i</code> is a <em>hash</em> or an <em>array</em>, then <code>make_xml_value(i)</code> recursivly construct the data tags.</p>

<p>For example:</p>

<pre><code>Call.make_xml_value &#39;some_str&#39; # =&gt;  &quot;&lt;string&gt;some_str&lt;/string&gt;&quot;
Call.make_xml_value 3.14159    # =&gt; &quot;&lt;double&gt;3.14159&lt;/double&gt;&quot;
Call.make_xml_value true       # =&gt; &quot;&lt;boolean&gt;1&lt;/boolean&gt;&quot;
</code></pre>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">make_xml_value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="k">case</span> <span class="n">i</span>
      <span class="k">when</span> <span class="nb">String</span>
        <span class="s2">&quot;&lt;string&gt;</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&lt;/string&gt;&quot;</span>
      <span class="k">when</span> <span class="no">Fixnum</span>
        <span class="s2">&quot;&lt;int&gt;</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&lt;/int&gt;&quot;</span>
      <span class="k">when</span> <span class="no">TrueClass</span>
        <span class="s2">&quot;&lt;boolean&gt;1&lt;/boolean&gt;&quot;</span>
      <span class="k">when</span> <span class="no">FalseClass</span>
        <span class="s2">&quot;&lt;boolean&gt;0&lt;/boolean&gt;&quot;</span>
      <span class="k">when</span> <span class="nb">Float</span>
        <span class="s2">&quot;&lt;double&gt;</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&lt;/double&gt;&quot;</span>
      <span class="k">when</span> <span class="nb">Array</span>
        <span class="n">array</span> <span class="o">=</span> <span class="s2">&quot;&lt;array&gt;&lt;data&gt;&quot;</span>
        <span class="n">i</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">array</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;value&gt;</span><span class="si">#{</span><span class="n">make_xml_value</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&lt;/value&gt;&quot;</span><span class="p">}</span>
        <span class="n">array</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;/data&gt;&lt;/array&gt;&quot;</span>

      <span class="k">when</span> <span class="no">Hash</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="s2">&quot;&lt;struct&gt;&quot;</span>
        <span class="n">i</span><span class="o">.</span><span class="n">each_pair</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
          <span class="n">struct</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;member&gt;&lt;name&gt;</span><span class="si">#{</span><span class="n">key</span><span class="si">}</span><span class="s2">&lt;/name&gt;&lt;value&gt;</span><span class="si">#{</span><span class="n">make_xml_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">&lt;/value&gt;&lt;/member&gt;&quot;</span>
        <span class="k">end</span>
        <span class="n">struct</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;&lt;/struct&gt;&quot;</span>

      <span class="k">else</span>
        <span class="k">raise</span> <span class="s2">&quot;Invalid XMLRPC value. &#39;</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">&#39; doesn&#39;t match any scalar types...&quot;</span>
      <span class="k">end</span>

    <span class="k">end</span>
  <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-Parser'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-Parser">&#182;</a>
        </div>
        <h4>Parser</h4>

<p><code>Parser</code> use the XML parsing module <a href="http://www.germane-software.com/software/rexml/">REXML</a> and language <a href="http://www.w3schools.com/xpath/xpath_examples.asp">XPath</a> to parse XMLRPC responses. Parser also convert XMLRPC response data into Ruby
data types/structures.</p>

<p>Note that parsing large XMLRPC responses are very time consuming. This is beacuse REXML is written in pure Ruby.
I will implement a fast XML parsing library in future versions of this XMLRPC module.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>  <span class="k">class</span> <span class="nc">Parser</span>
    <span class="nb">require</span> <span class="s1">&#39;rexml/document&#39;</span>
    </pre></div>
      </td>
    </tr>
    <tr id='section-15'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-15">&#182;</a>
        </div>
        <p><code>Parser</code> has one public atribute named <code>@response</code>. <code>@response</code> is an array. Parsed XMLRPC values are apended to <code>@response</code>. If
XMLRPC response type is <em>fault</em>, then <code>:fault</code> symbol is added to <code>@response</code> as the first item.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="kp">attr_reader</span> <span class="ss">:response</span></pre></div>
      </td>
    </tr>
    <tr id='section-16'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-16">&#182;</a>
        </div>
        <p><code>parse</code> method is called when <code>xml_response</code> is provided.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">xml_response</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">parse</span> <span class="n">xml_response</span> <span class="k">if</span> <span class="n">xml_response</span>
    <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-17'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-17">&#182;</a>
        </div>
        <p><code>parse</code> method take a XML string for input. <code>parse</code> method populate the array <code>@response</code> with Ruby data types/
structures. The item(s) in <code>@response</code> match the order of encoded data in the XMLRPC response.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">parse</span> <span class="p">(</span><span class="n">response</span><span class="p">)</span></pre></div>
      </td>
    </tr>
    <tr id='section-18'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-18">&#182;</a>
        </div>
        <p><code>parse</code> method first create a REXML document by passing in <code>response</code> to <code>REXML::Document</code>.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="vi">@xml_response</span> <span class="o">=</span> <span class="no">REXML</span><span class="o">::</span><span class="no">Document</span><span class="o">.</span><span class="n">new</span> <span class="n">response</span>
      <span class="vi">@response</span>     <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span></pre></div>
      </td>
    </tr>
    <tr id='section-19'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-19">&#182;</a>
        </div>
        <p><code>parse</code> method checks for <em>fault</em> XMLRPC response by searching for the path <code>methodResponse/fault</code> in the REXML
document (see <em>Response format</em> section at <a href="http://xmlrpc.scripting.com/spec.html">http://xmlrpc.scripting.com/spec.html</a>). If such path exist, 
then <code>parse</code> method will parse the <em>fault code</em> and <em>fault string</em> into a Ruby hash. Also, <code>:fault</code> symbol is added to <code>@response</code> 
as the first item.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">if</span> <span class="vi">@xml_response</span><span class="o">.</span><span class="n">elements</span><span class="o">[</span><span class="s1">&#39;methodResponse/fault&#39;</span><span class="o">]</span>
        <span class="vi">@response</span> <span class="o">&lt;&lt;</span> <span class="ss">:fault</span>
        
        <span class="vi">@xml_response</span><span class="o">.</span><span class="n">elements</span><span class="o">[</span><span class="s1">&#39;methodResponse/fault/value&#39;</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">fault_struct</span><span class="o">|</span> 
          <span class="n">parse_value</span> <span class="n">fault_struct</span>
        <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-20'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-20">&#182;</a>
        </div>
        <p>If a fault XMLRPC response was not found, then <code>parse</code> method looks for the path
<code>methodResponse/params/param/value</code>. If such path exist, then <code>parse</code> method continue parsing 
XMLRPC response values. <code>parse</code> call <code>parse_value</code> for each scalar values such as string, int, 
bool etc.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">elsif</span> <span class="vi">@xml_response</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="s1">&#39;methodResponse/params/param/value&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>

          <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has_elements?</span>
            <span class="n">i</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">value</span><span class="o">|</span> <span class="nb">self</span><span class="o">.</span><span class="n">parse_value</span> <span class="n">value</span><span class="p">}</span>
          </pre></div>
      </td>
    </tr>
    <tr id='section-21'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-21">&#182;</a>
        </div>
        <p>If XMLRPC response values are not enclosed in any tags, <code>parse</code> method add <code>nil</code> or actual text value to <code>@response</code>.</p>

<p>For example,</p>

<pre><code>  &lt;value&gt;FOO&lt;/value&gt; # text FOO will be added to @response
  &lt;value&gt;&lt;/value&gt;    # nil will be added to @response
</code></pre>
      </td>
      <td class=code>
        <div class='highlight'><pre>          <span class="k">else</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has_text?</span>
              <span class="vi">@response</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">.</span><span class="n">text</span>
            <span class="k">else</span>
              <span class="vi">@response</span> <span class="o">&lt;&lt;</span> <span class="kp">nil</span>
            <span class="k">end</span>
          <span class="k">end</span>
      <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-22'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-22">&#182;</a>
        </div>
        <p>If path <code>methodResponse/params/param/value</code> does not exist, then <code>parse</code> method treat input string <code>response</code> as an invalid
XMLRPC response. <code>parse</code> method raise an exception when XMLRPC response is invalid. The exception diplay the first 256 characters
of the <code>response</code> string.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">else</span>
        <span class="k">raise</span> <span class="s2">&quot;Invalid XMLRPC response: </span><span class="si">#{</span><span class="vi">@xml_response</span><span class="o">[</span><span class="mi">256</span><span class="o">]</span><span class="si">}</span><span class="s2">...&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-23'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-23">&#182;</a>
        </div>
        <p><code>parse_value</code> accept two values: <code>value</code> and <code>response</code> (where <code>response</code> is optional). <code>parse</code> method pass <code>value</code> which 
is a REXML data type.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">def</span> <span class="nf">parse_value</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">response</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span></pre></div>
      </td>
    </tr>
    <tr id='section-24'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-24">&#182;</a>
        </div>
        <p>First, <code>parse_value</code> check if a diffrent <code>response</code> variable is given. If not, <code>parse_value</code> 
use the default <code>@response</code> variable. Then <code>parse_value</code> store <code>value</code> name in <code>value_type</code>. 
For example, if <code>value</code> was <em>&lt;double&gt;2.71828183&lt;/double&gt;</em>, then <code>value_type</code> would be <em>double</em>.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="n">response</span> <span class="o">=</span> <span class="n">response</span> <span class="o">||</span> <span class="vi">@response</span>  <span class="c1"># When the value is a list, we do not want to effect the response list</span>
      <span class="n">value_type</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">name</span></pre></div>
      </td>
    </tr>
    <tr id='section-25'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-25">&#182;</a>
        </div>
        <p><code>parse_value</code> use a case statement to check each possible XMLRPC data type. When a valid data type is found, <code>value</code>&#39;s
text is converted to a Ruby data type/structure and appended to <code>response</code>. For example, 
if <code>value</code> is <em>&lt;double&gt;2.71828183&lt;/double&gt;</em>, then <code>value</code> text <em>&#39;2.71828183&#39;</em> is converted to a 
float and appended to <code>response</code>.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">case</span> <span class="n">value_type</span>

      <span class="k">when</span> <span class="s1">&#39;string&#39;</span>
        <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="o">.</span><span class="n">text</span>
      <span class="k">when</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span>
        <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">to_i</span>
      <span class="k">when</span> <span class="s1">&#39;double&#39;</span>
        <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">to_f</span>
      <span class="k">when</span> <span class="s1">&#39;boolean&#39;</span>

        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span>
          <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="kp">false</span>
        <span class="k">elsif</span> <span class="n">value</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span>
          <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="kp">true</span>
        <span class="k">else</span>
          <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="ss">:invalid_boolean</span>
        <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-26'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-26">&#182;</a>
        </div>
        <p><code>parse_value</code> parse each item in <code>value</code> recursivly when <code>value</code> type is a XMLRPC <em>&lt;array&gt;</em>.
First, <code>parse_value</code> creates a new array. Then <code>parse_value</code> call itself for each item in <code>value</code> like 
following: <code>parse_value(i, array)</code> where <code>i</code> is an item in the XMLRPC array and <code>array</code> is the newly crated array.</p>

<p>Because <code>parse_value</code> pass <code>array</code> to itself, <code>parse_value</code> append parsed XMLRPC array items to
<code>array</code> variable (which will be appended to <code>@response</code> later).</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">when</span> <span class="s1">&#39;array&#39;</span>
        <span class="n">array</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span>
        <span class="n">value</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="s1">&#39;data/value/*&#39;</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">parse_value</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">array</span><span class="p">)}</span>
        <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="n">array</span></pre></div>
      </td>
    </tr>
    <tr id='section-27'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-27">&#182;</a>
        </div>
        <p><code>parse_value</code> method also parse XMLRPC <em><struct\></em> recursivly. XMLRPC structs are converted into Ruby hashes.
First, <code>parse_value</code> creates two arrays named <code>hash_key</code> and <code>hash_values</code>. Then <code>parse_value</code> poppulate  <code>hash_keys</code> with 
each <em>&#39;member/name&#39;</em> of the XMLRPC struct. Then <code>parse_value</code> populate <code>hash_value</code> with each <em>&#39;member/value&#39;</em> of the 
XMLRPC struct. </p>

<p>Some XMLRPC response servers do not adhear to XMLRPC specifications. To make <code>Parser</code> compatible with such
servers, the following is done: <code>nil</code> is inserted into <code>hash_values</code> when <em>&lt;value&gt;</em> is empty. Data in 
<em>&lt;value&gt;</em> tag is converted to text when <em>&lt;value&gt;</em> tag is not empty. Finally, <code>hash_values</code> and
<code>hash_keys</code> are zipped into a Ruby hash and appended to <code>response</code>.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">when</span> <span class="s1">&#39;struct&#39;</span>
        <span class="n">hash_keys</span>   <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span>
        <span class="n">hash_values</span> <span class="o">=</span> <span class="nb">Array</span><span class="o">.</span><span class="n">new</span>

        <span class="n">value</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="s1">&#39;member/name&#39;</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">hash_keys</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">.</span><span class="n">text</span><span class="p">}</span>

        <span class="n">value</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="s1">&#39;member/value&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
          <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has_text?</span>
            <span class="n">hash_values</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">.</span><span class="n">text</span>
          <span class="k">elsif</span> <span class="n">i</span><span class="o">.</span><span class="n">has_elements?</span>
            <span class="n">i</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">parse_value</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">hash_values</span><span class="p">)}</span>
          <span class="k">else</span>
            <span class="n">hash_values</span> <span class="o">&lt;&lt;</span> <span class="kp">nil</span>
          <span class="k">end</span>
        <span class="k">end</span>

        <span class="n">h</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span>
        <span class="n">hash_keys</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">hash_values</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">h</span><span class="o">[</span><span class="n">i</span><span class="o">.</span><span class="n">first</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">last</span><span class="p">}</span>
        <span class="n">response</span> <span class="o">&lt;&lt;</span> <span class="n">h</span></pre></div>
      </td>
    </tr>
    <tr id='section-28'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-28">&#182;</a>
        </div>
        <p>If <code>value</code> does not match any XMLRPC data types this exception is raised.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>      <span class="k">else</span>
        <span class="k">raise</span>  <span class="s2">&quot;[!] Could not parse scalar type &#39;</span><span class="si">#{</span><span class="n">value_type</span><span class="si">}</span><span class="s2">&#39; from xml&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span>

  <span class="k">end</span>

<span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-Word_Count:'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-Word_Count:">&#182;</a>
        </div>
        <h4>Word Count:</h4>

<p>1057</p>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-Active_voice_sentences:'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-Active_voice_sentences:">&#182;</a>
        </div>
        <h4>Active voice sentences:</h4>

<ul>
<li><code>Parser</code> use the XML parsing module <a href="http://www.germane-software.com/software/rexml/">REXML</a> and language <a href="http://www.w3schools.com/xpath/xpath_examples.asp">XPath</a> to parse XMLRPC responses.</li>
<li><code>parse_value</code> parse each item in <code>value</code> recursivly when <code>value</code> type is a XMLRPC <em>&lt;array&gt;</em>.</li>
<li><code>Parser</code> has one public atribute named <code>@response</code>.</li>
</ul>

      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
  </table>
</div>
</body>
